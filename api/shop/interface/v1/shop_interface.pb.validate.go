// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: shop/interface/v1/shop_interface.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Category with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Category) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Category with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CategoryMultiError, or nil
// if none found.
func (m *Category) ValidateAll() error {
	return m.validate(true)
}

func (m *Category) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CategoryName

	if len(errors) > 0 {
		return CategoryMultiError(errors)
	}

	return nil
}

// CategoryMultiError is an error wrapping multiple validation errors returned
// by Category.ValidateAll() if the designated constraints aren't met.
type CategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMultiError) AllErrors() []error { return m }

// CategoryValidationError is the validation error returned by
// Category.Validate if the designated constraints aren't met.
type CategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryValidationError) ErrorName() string { return "CategoryValidationError" }

// Error satisfies the builtin error interface
func (e CategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryValidationError{}

// Validate checks the field values on ListCategoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCategoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCategoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCategoryRequestMultiError, or nil if none found.
func (m *ListCategoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCategoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListCategoryRequestMultiError(errors)
	}

	return nil
}

// ListCategoryRequestMultiError is an error wrapping multiple validation
// errors returned by ListCategoryRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCategoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCategoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCategoryRequestMultiError) AllErrors() []error { return m }

// ListCategoryRequestValidationError is the validation error returned by
// ListCategoryRequest.Validate if the designated constraints aren't met.
type ListCategoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCategoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCategoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCategoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCategoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCategoryRequestValidationError) ErrorName() string {
	return "ListCategoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCategoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCategoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCategoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCategoryRequestValidationError{}

// Validate checks the field values on ListCategoryReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListCategoryReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCategoryReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCategoryReplyMultiError, or nil if none found.
func (m *ListCategoryReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCategoryReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCategories() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCategoryReplyValidationError{
						field:  fmt.Sprintf("Categories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCategoryReplyValidationError{
						field:  fmt.Sprintf("Categories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCategoryReplyValidationError{
					field:  fmt.Sprintf("Categories[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCategoryReplyMultiError(errors)
	}

	return nil
}

// ListCategoryReplyMultiError is an error wrapping multiple validation errors
// returned by ListCategoryReply.ValidateAll() if the designated constraints
// aren't met.
type ListCategoryReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCategoryReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCategoryReplyMultiError) AllErrors() []error { return m }

// ListCategoryReplyValidationError is the validation error returned by
// ListCategoryReply.Validate if the designated constraints aren't met.
type ListCategoryReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCategoryReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCategoryReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCategoryReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCategoryReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCategoryReplyValidationError) ErrorName() string {
	return "ListCategoryReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListCategoryReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCategoryReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCategoryReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCategoryReplyValidationError{}

// Validate checks the field values on GoodsInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GoodsInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoodsInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GoodsInfoMultiError, or nil
// if none found.
func (m *GoodsInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *GoodsInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Kind

	// no validation rules for Content

	if len(errors) > 0 {
		return GoodsInfoMultiError(errors)
	}

	return nil
}

// GoodsInfoMultiError is an error wrapping multiple validation errors returned
// by GoodsInfo.ValidateAll() if the designated constraints aren't met.
type GoodsInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoodsInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoodsInfoMultiError) AllErrors() []error { return m }

// GoodsInfoValidationError is the validation error returned by
// GoodsInfo.Validate if the designated constraints aren't met.
type GoodsInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoodsInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoodsInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoodsInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoodsInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoodsInfoValidationError) ErrorName() string { return "GoodsInfoValidationError" }

// Error satisfies the builtin error interface
func (e GoodsInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoodsInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoodsInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoodsInfoValidationError{}

// Validate checks the field values on GoodsSimplify with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GoodsSimplify) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoodsSimplify with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GoodsSimplifyMultiError, or
// nil if none found.
func (m *GoodsSimplify) ValidateAll() error {
	return m.validate(true)
}

func (m *GoodsSimplify) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SpuNo

	// no validation rules for GoodsName

	// no validation rules for StartPrice

	// no validation rules for CategoryId

	// no validation rules for BrandId

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GoodsSimplifyValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GoodsSimplifyValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GoodsSimplifyValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GoodsSimplifyMultiError(errors)
	}

	return nil
}

// GoodsSimplifyMultiError is an error wrapping multiple validation errors
// returned by GoodsSimplify.ValidateAll() if the designated constraints
// aren't met.
type GoodsSimplifyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoodsSimplifyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoodsSimplifyMultiError) AllErrors() []error { return m }

// GoodsSimplifyValidationError is the validation error returned by
// GoodsSimplify.Validate if the designated constraints aren't met.
type GoodsSimplifyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoodsSimplifyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoodsSimplifyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoodsSimplifyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoodsSimplifyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoodsSimplifyValidationError) ErrorName() string { return "GoodsSimplifyValidationError" }

// Error satisfies the builtin error interface
func (e GoodsSimplifyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoodsSimplify.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoodsSimplifyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoodsSimplifyValidationError{}

// Validate checks the field values on GoodsDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GoodsDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoodsDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GoodsDetailMultiError, or
// nil if none found.
func (m *GoodsDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *GoodsDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SpuNo

	// no validation rules for GoodsName

	// no validation rules for GoodsDesc

	// no validation rules for StartPrice

	// no validation rules for CategoryId

	// no validation rules for BrandId

	for idx, item := range m.GetInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GoodsDetailValidationError{
						field:  fmt.Sprintf("Infos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GoodsDetailValidationError{
						field:  fmt.Sprintf("Infos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GoodsDetailValidationError{
					field:  fmt.Sprintf("Infos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GoodsDetailMultiError(errors)
	}

	return nil
}

// GoodsDetailMultiError is an error wrapping multiple validation errors
// returned by GoodsDetail.ValidateAll() if the designated constraints aren't met.
type GoodsDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoodsDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoodsDetailMultiError) AllErrors() []error { return m }

// GoodsDetailValidationError is the validation error returned by
// GoodsDetail.Validate if the designated constraints aren't met.
type GoodsDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoodsDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoodsDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoodsDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoodsDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoodsDetailValidationError) ErrorName() string { return "GoodsDetailValidationError" }

// Error satisfies the builtin error interface
func (e GoodsDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoodsDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoodsDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoodsDetailValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrentPage

	// no validation rules for PageSize

	// no validation rules for FirstPage

	// no validation rules for LastPage

	// no validation rules for TotalRecords

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on GetGoodsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetGoodsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGoodsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetGoodsRequestMultiError, or nil if none found.
func (m *GetGoodsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGoodsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetGoodsRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetGoodsRequestMultiError(errors)
	}

	return nil
}

// GetGoodsRequestMultiError is an error wrapping multiple validation errors
// returned by GetGoodsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetGoodsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGoodsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGoodsRequestMultiError) AllErrors() []error { return m }

// GetGoodsRequestValidationError is the validation error returned by
// GetGoodsRequest.Validate if the designated constraints aren't met.
type GetGoodsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGoodsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGoodsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGoodsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGoodsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGoodsRequestValidationError) ErrorName() string { return "GetGoodsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetGoodsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGoodsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGoodsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGoodsRequestValidationError{}

// Validate checks the field values on GetGoodsReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetGoodsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGoodsReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetGoodsReplyMultiError, or
// nil if none found.
func (m *GetGoodsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGoodsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGoods()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetGoodsReplyValidationError{
					field:  "Goods",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetGoodsReplyValidationError{
					field:  "Goods",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGoods()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetGoodsReplyValidationError{
				field:  "Goods",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetGoodsReplyMultiError(errors)
	}

	return nil
}

// GetGoodsReplyMultiError is an error wrapping multiple validation errors
// returned by GetGoodsReply.ValidateAll() if the designated constraints
// aren't met.
type GetGoodsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGoodsReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGoodsReplyMultiError) AllErrors() []error { return m }

// GetGoodsReplyValidationError is the validation error returned by
// GetGoodsReply.Validate if the designated constraints aren't met.
type GetGoodsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGoodsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGoodsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGoodsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGoodsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGoodsReplyValidationError) ErrorName() string { return "GetGoodsReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetGoodsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGoodsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGoodsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGoodsReplyValidationError{}

// Validate checks the field values on ListGoodsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListGoodsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListGoodsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListGoodsRequestMultiError, or nil if none found.
func (m *ListGoodsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListGoodsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCategoryId() != 0 {

		if m.GetCategoryId() <= 0 {
			err := ListGoodsRequestValidationError{
				field:  "CategoryId",
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetPage() != 0 {

		if val := m.GetPage(); val <= 0 || val > 10000000 {
			err := ListGoodsRequestValidationError{
				field:  "Page",
				reason: "value must be inside range (0, 10000000]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetPageSize() != 0 {

		if val := m.GetPageSize(); val <= 0 || val > 100 {
			err := ListGoodsRequestValidationError{
				field:  "PageSize",
				reason: "value must be inside range (0, 100]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ListGoodsRequestMultiError(errors)
	}

	return nil
}

// ListGoodsRequestMultiError is an error wrapping multiple validation errors
// returned by ListGoodsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListGoodsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListGoodsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListGoodsRequestMultiError) AllErrors() []error { return m }

// ListGoodsRequestValidationError is the validation error returned by
// ListGoodsRequest.Validate if the designated constraints aren't met.
type ListGoodsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListGoodsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListGoodsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListGoodsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListGoodsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListGoodsRequestValidationError) ErrorName() string { return "ListGoodsRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListGoodsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListGoodsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListGoodsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListGoodsRequestValidationError{}

// Validate checks the field values on ListGoodsReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListGoodsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListGoodsReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListGoodsReplyMultiError,
// or nil if none found.
func (m *ListGoodsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListGoodsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGoodsList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListGoodsReplyValidationError{
						field:  fmt.Sprintf("GoodsList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListGoodsReplyValidationError{
						field:  fmt.Sprintf("GoodsList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListGoodsReplyValidationError{
					field:  fmt.Sprintf("GoodsList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListGoodsReplyValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListGoodsReplyValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListGoodsReplyValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListGoodsReplyMultiError(errors)
	}

	return nil
}

// ListGoodsReplyMultiError is an error wrapping multiple validation errors
// returned by ListGoodsReply.ValidateAll() if the designated constraints
// aren't met.
type ListGoodsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListGoodsReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListGoodsReplyMultiError) AllErrors() []error { return m }

// ListGoodsReplyValidationError is the validation error returned by
// ListGoodsReply.Validate if the designated constraints aren't met.
type ListGoodsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListGoodsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListGoodsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListGoodsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListGoodsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListGoodsReplyValidationError) ErrorName() string { return "ListGoodsReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListGoodsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListGoodsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListGoodsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListGoodsReplyValidationError{}

// Validate checks the field values on GetSKUsRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetSKUsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSKUsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetSKUsRequestMultiError,
// or nil if none found.
func (m *GetSKUsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSKUsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if wrapper := m.GetId(); wrapper != nil {

		if wrapper.GetValue() <= 0 {
			err := GetSKUsRequestValidationError{
				field:  "Id",
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	} else {
		err := GetSKUsRequestValidationError{
			field:  "Id",
			reason: "value is required and must not be nil.",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSKUsRequestMultiError(errors)
	}

	return nil
}

// GetSKUsRequestMultiError is an error wrapping multiple validation errors
// returned by GetSKUsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSKUsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSKUsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSKUsRequestMultiError) AllErrors() []error { return m }

// GetSKUsRequestValidationError is the validation error returned by
// GetSKUsRequest.Validate if the designated constraints aren't met.
type GetSKUsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSKUsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSKUsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSKUsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSKUsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSKUsRequestValidationError) ErrorName() string { return "GetSKUsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetSKUsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSKUsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSKUsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSKUsRequestValidationError{}

// Validate checks the field values on GetSKUsReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetSKUsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSKUsReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetSKUsReplyMultiError, or
// nil if none found.
func (m *GetSKUsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSKUsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSkus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSKUsReplyValidationError{
						field:  fmt.Sprintf("Skus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSKUsReplyValidationError{
						field:  fmt.Sprintf("Skus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSKUsReplyValidationError{
					field:  fmt.Sprintf("Skus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAttrs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSKUsReplyValidationError{
						field:  fmt.Sprintf("Attrs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSKUsReplyValidationError{
						field:  fmt.Sprintf("Attrs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSKUsReplyValidationError{
					field:  fmt.Sprintf("Attrs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSKUsReplyMultiError(errors)
	}

	return nil
}

// GetSKUsReplyMultiError is an error wrapping multiple validation errors
// returned by GetSKUsReply.ValidateAll() if the designated constraints aren't met.
type GetSKUsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSKUsReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSKUsReplyMultiError) AllErrors() []error { return m }

// GetSKUsReplyValidationError is the validation error returned by
// GetSKUsReply.Validate if the designated constraints aren't met.
type GetSKUsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSKUsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSKUsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSKUsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSKUsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSKUsReplyValidationError) ErrorName() string { return "GetSKUsReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetSKUsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSKUsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSKUsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSKUsReplyValidationError{}

// Validate checks the field values on GoodsSKU with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GoodsSKU) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoodsSKU with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GoodsSKUMultiError, or nil
// if none found.
func (m *GoodsSKU) ValidateAll() error {
	return m.validate(true)
}

func (m *GoodsSKU) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for GoodsId

	// no validation rules for Price

	// no validation rules for Stock

	if len(errors) > 0 {
		return GoodsSKUMultiError(errors)
	}

	return nil
}

// GoodsSKUMultiError is an error wrapping multiple validation errors returned
// by GoodsSKU.ValidateAll() if the designated constraints aren't met.
type GoodsSKUMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoodsSKUMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoodsSKUMultiError) AllErrors() []error { return m }

// GoodsSKUValidationError is the validation error returned by
// GoodsSKU.Validate if the designated constraints aren't met.
type GoodsSKUValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoodsSKUValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoodsSKUValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoodsSKUValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoodsSKUValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoodsSKUValidationError) ErrorName() string { return "GoodsSKUValidationError" }

// Error satisfies the builtin error interface
func (e GoodsSKUValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoodsSKU.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoodsSKUValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoodsSKUValidationError{}

// Validate checks the field values on GoodsAttr with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GoodsAttr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoodsAttr with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GoodsAttrMultiError, or nil
// if none found.
func (m *GoodsAttr) ValidateAll() error {
	return m.validate(true)
}

func (m *GoodsAttr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for GoodsId

	// no validation rules for AttrKey

	for idx, item := range m.GetAttrValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GoodsAttrValidationError{
						field:  fmt.Sprintf("AttrValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GoodsAttrValidationError{
						field:  fmt.Sprintf("AttrValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GoodsAttrValidationError{
					field:  fmt.Sprintf("AttrValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GoodsAttrMultiError(errors)
	}

	return nil
}

// GoodsAttrMultiError is an error wrapping multiple validation errors returned
// by GoodsAttr.ValidateAll() if the designated constraints aren't met.
type GoodsAttrMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoodsAttrMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoodsAttrMultiError) AllErrors() []error { return m }

// GoodsAttrValidationError is the validation error returned by
// GoodsAttr.Validate if the designated constraints aren't met.
type GoodsAttrValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoodsAttrValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoodsAttrValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoodsAttrValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoodsAttrValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoodsAttrValidationError) ErrorName() string { return "GoodsAttrValidationError" }

// Error satisfies the builtin error interface
func (e GoodsAttrValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoodsAttr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoodsAttrValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoodsAttrValidationError{}

// Validate checks the field values on GoodsAttrValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GoodsAttrValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoodsAttrValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GoodsAttrValueMultiError,
// or nil if none found.
func (m *GoodsAttrValue) ValidateAll() error {
	return m.validate(true)
}

func (m *GoodsAttrValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AttrKeyId

	// no validation rules for AttrValue

	if len(errors) > 0 {
		return GoodsAttrValueMultiError(errors)
	}

	return nil
}

// GoodsAttrValueMultiError is an error wrapping multiple validation errors
// returned by GoodsAttrValue.ValidateAll() if the designated constraints
// aren't met.
type GoodsAttrValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoodsAttrValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoodsAttrValueMultiError) AllErrors() []error { return m }

// GoodsAttrValueValidationError is the validation error returned by
// GoodsAttrValue.Validate if the designated constraints aren't met.
type GoodsAttrValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoodsAttrValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoodsAttrValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoodsAttrValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoodsAttrValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoodsAttrValueValidationError) ErrorName() string { return "GoodsAttrValueValidationError" }

// Error satisfies the builtin error interface
func (e GoodsAttrValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoodsAttrValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoodsAttrValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoodsAttrValueValidationError{}

// Validate checks the field values on WxLoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WxLoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WxLoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WxLoginRequestMultiError,
// or nil if none found.
func (m *WxLoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WxLoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if wrapper := m.GetCode(); wrapper != nil {

		if utf8.RuneCountInString(wrapper.GetValue()) < 5 {
			err := WxLoginRequestValidationError{
				field:  "Code",
				reason: "value length must be at least 5 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	} else {
		err := WxLoginRequestValidationError{
			field:  "Code",
			reason: "value is required and must not be nil.",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetEncryptedData(); wrapper != nil {

		if utf8.RuneCountInString(wrapper.GetValue()) < 10 {
			err := WxLoginRequestValidationError{
				field:  "EncryptedData",
				reason: "value length must be at least 10 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	} else {
		err := WxLoginRequestValidationError{
			field:  "EncryptedData",
			reason: "value is required and must not be nil.",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetIv(); wrapper != nil {

		if utf8.RuneCountInString(wrapper.GetValue()) < 5 {
			err := WxLoginRequestValidationError{
				field:  "Iv",
				reason: "value length must be at least 5 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	} else {
		err := WxLoginRequestValidationError{
			field:  "Iv",
			reason: "value is required and must not be nil.",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SessionIsValid

	if len(errors) > 0 {
		return WxLoginRequestMultiError(errors)
	}

	return nil
}

// WxLoginRequestMultiError is an error wrapping multiple validation errors
// returned by WxLoginRequest.ValidateAll() if the designated constraints
// aren't met.
type WxLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WxLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WxLoginRequestMultiError) AllErrors() []error { return m }

// WxLoginRequestValidationError is the validation error returned by
// WxLoginRequest.Validate if the designated constraints aren't met.
type WxLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WxLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WxLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WxLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WxLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WxLoginRequestValidationError) ErrorName() string { return "WxLoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e WxLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWxLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WxLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WxLoginRequestValidationError{}

// Validate checks the field values on WxLoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WxLoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WxLoginReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WxLoginReplyMultiError, or
// nil if none found.
func (m *WxLoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *WxLoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return WxLoginReplyMultiError(errors)
	}

	return nil
}

// WxLoginReplyMultiError is an error wrapping multiple validation errors
// returned by WxLoginReply.ValidateAll() if the designated constraints aren't met.
type WxLoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WxLoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WxLoginReplyMultiError) AllErrors() []error { return m }

// WxLoginReplyValidationError is the validation error returned by
// WxLoginReply.Validate if the designated constraints aren't met.
type WxLoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WxLoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WxLoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WxLoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WxLoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WxLoginReplyValidationError) ErrorName() string { return "WxLoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e WxLoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWxLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WxLoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WxLoginReplyValidationError{}

// Validate checks the field values on AddCartRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddCartRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCartRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddCartRequestMultiError,
// or nil if none found.
func (m *AddCartRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCartRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if wrapper := m.GetGoodsId(); wrapper != nil {

		if wrapper.GetValue() <= 0 {
			err := AddCartRequestValidationError{
				field:  "GoodsId",
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	} else {
		err := AddCartRequestValidationError{
			field:  "GoodsId",
			reason: "value is required and must not be nil.",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetGoodsSkuId(); wrapper != nil {

		if wrapper.GetValue() <= 0 {
			err := AddCartRequestValidationError{
				field:  "GoodsSkuId",
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	} else {
		err := AddCartRequestValidationError{
			field:  "GoodsSkuId",
			reason: "value is required and must not be nil.",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetGoodsSkuDesc(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 1 || l > 50 {
			err := AddCartRequestValidationError{
				field:  "GoodsSkuDesc",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	} else {
		err := AddCartRequestValidationError{
			field:  "GoodsSkuDesc",
			reason: "value is required and must not be nil.",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddCartRequestMultiError(errors)
	}

	return nil
}

// AddCartRequestMultiError is an error wrapping multiple validation errors
// returned by AddCartRequest.ValidateAll() if the designated constraints
// aren't met.
type AddCartRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCartRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCartRequestMultiError) AllErrors() []error { return m }

// AddCartRequestValidationError is the validation error returned by
// AddCartRequest.Validate if the designated constraints aren't met.
type AddCartRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCartRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCartRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCartRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCartRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCartRequestValidationError) ErrorName() string { return "AddCartRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddCartRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCartRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCartRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCartRequestValidationError{}

// Validate checks the field values on Cart with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Cart) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cart with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CartMultiError, or nil if none found.
func (m *Cart) ValidateAll() error {
	return m.validate(true)
}

func (m *Cart) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for GoodsId

	// no validation rules for GoodsSkuId

	// no validation rules for GoodsSkuDesc

	// no validation rules for Num

	if len(errors) > 0 {
		return CartMultiError(errors)
	}

	return nil
}

// CartMultiError is an error wrapping multiple validation errors returned by
// Cart.ValidateAll() if the designated constraints aren't met.
type CartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CartMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CartMultiError) AllErrors() []error { return m }

// CartValidationError is the validation error returned by Cart.Validate if the
// designated constraints aren't met.
type CartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CartValidationError) ErrorName() string { return "CartValidationError" }

// Error satisfies the builtin error interface
func (e CartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CartValidationError{}

// Validate checks the field values on AddCartReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddCartReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCartReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddCartReplyMultiError, or
// nil if none found.
func (m *AddCartReply) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCartReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddCartReplyValidationError{
					field:  "Cart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddCartReplyValidationError{
					field:  "Cart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddCartReplyValidationError{
				field:  "Cart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddCartReplyMultiError(errors)
	}

	return nil
}

// AddCartReplyMultiError is an error wrapping multiple validation errors
// returned by AddCartReply.ValidateAll() if the designated constraints aren't met.
type AddCartReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCartReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCartReplyMultiError) AllErrors() []error { return m }

// AddCartReplyValidationError is the validation error returned by
// AddCartReply.Validate if the designated constraints aren't met.
type AddCartReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCartReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCartReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCartReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCartReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCartReplyValidationError) ErrorName() string { return "AddCartReplyValidationError" }

// Error satisfies the builtin error interface
func (e AddCartReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCartReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCartReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCartReplyValidationError{}
